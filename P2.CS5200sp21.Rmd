---
title: "Practicum 2"
output: html_notebook
---

##### Import statements
```{r}
library(RSQLite)
library(XML)
library(DBI)
library(knitr)
```

##### ERD for the schema
![Database ERD]()

##### creating databse connection
```{r}
path <- "/Users/rohan/Documents/Masters/5200Databases/Practicum2/"
fn <- "pubmed_sample.xml"
fpn = paste0(path, fn)
dbfn <- "part1.db"
dbfpn = paste0(path, dbfn)

part1db <- dbConnect(RSQLite::SQLite(), dbfpn)
```

```{sql connection=part1db}
DROP TABLE IF EXISTS Article;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Authorship;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Author;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Journal;
```

##### Create table schema
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Journal (
  jornal_id INT PRIMARY KEY,
  ISSN TEXT NOT NULL,
  volume INT NOT NULL,
  issue INT NOT NULL,
  pubYear TEXT NOT NULL,
  pubMonth TEXT,
  title TEXT NOT NULL,
  ISOabbreviation TEXT NOT NULL
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Author (
  author_id INT PRIMARY KEY,
  lname TEXT NOT NULL,
  fname TEXT NOT NULL,
  initials TEXT NOT NULL
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Article (
  article_id INT PRIMARY KEY,
  journal_id INT NOT NULL,
  title TEXT NOT NULL,
  pagination TEXT,
  eLocationID TEXT,
  language TEXT,
  FOREIGN KEY (journal_id) REFERENCES Journal(journal_id)
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Authorship (
  author_id INT NOT NULL,
  article_id INT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES Author(author_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id)
)
```
```{sql connection=part1db}
SELECT 
    name
FROM 
    sqlite_master 
WHERE 
    type ='table' AND 
    name NOT LIKE 'sqlite_%';
```

##### Part 1 #3 dataframes to load into the database
```{r}
# Reading the XML file and parse into DOM
xmlDOM <- xmlParse(file = fpn)

# get the root node of the DOM tree
r <- xmlRoot(xmlDOM)

# get number of children of root (number of articles)
numArticle <- xmlSize(r)

# create various data frames to hold data; initial values are just
# to define data type and length and will be replaced; pre-allocation
# is better for performance than dynamic allocation of memory
Article.df <- data.frame (article_id = vector (mode = "integer", 
                                     length = numArticle),
                     journal_id = vector (mode = "integer", 
                                         length = numArticle),
                     title = vector (mode = "character", 
                                       length = numArticle),
                     pagination = vector (mode = "character", 
                                        length = numArticle),
                     eLocationID = vector (mode = "character", 
                                        length = numArticle),
                     language = vector (mode = "character", 
                                        length = numArticle),
                     stringsAsFactors = F)

Journal.df <- data.frame (jid = integer(),
                          issn = character(),
                          volume = character(),
                          issue = character(),
                          pubYear = character(),
                          pubMonth = character(),
                          title = character(),
                          ISOabbrev = character(),
                          stringsAsFactors = F)

Author.df <- data.frame (aid = integer(),
                       lname = character(),
                       fname = character(),
                       initials = character(),
                       stringsAsFactors = F)

Authorship.df <- data.frame (articleID = integer(),
                       authorID = integer(),
                       stringsAsFactors = F)

```

##### Helper functions
```{r}
parseJournal <- function (aJournalNode)
{
  # parse the address into its components
  issn <- xmlValue(aJournalNode[[1]])
  issueNode <- aJournalNode[[2]]
  title <- xmlValue(aJournalNode[[3]])
  ISOabbrev <- xmlValue(aJournalNode[[4]])
  
  volume <- xmlValue(issueNode[[1]])
  issue <- xmlValue(issueNode[[2]])
  dateNode <- issueNode[[3]]
  
  # Check if the PubDate is a MedlineDate type
  if (xmlName(dateNode[[1]]) == "MedlineDate") {
    pubDate <- xmlValue(dateNode[[1]])
    pubYear <- substr(pubDate, 1, 4)
    pubMonth <- substr(pubDate, 6, 8)
  } else { # Otherwise it's in Year and Month format
    pubYear <- xmlValue(dateNode[[1]])
    pubMonth <- xpathSApply(dateNode, "./Month", xmlValue)
    if (length(pubMonth) == 0) {
      pubMonth = NA
    }
  }
  
  newJournal.df <- data.frame(issn, volume, issue, pubYear, 
                              pubMonth, title, ISOabbrev, 
                           stringsAsFactors = F)
  
  return(newJournal.df)
}

parseAuthors <- function(AuthorListNode)
{
  newAuthors.df <- data.frame (lname = character(),
                                fname = character(),
                                initials = character(),
                                stringsAsFactors = F)

  n <- xmlSize(AuthorListNode)
  
  # extract each of the <Author> nodes under <AuthorList>
  for (m in 1:n)
  {
    anAuthor <- AuthorListNode[[m]]
    lname <- xmlValue(anAuthor[[1]])
    fname <- xmlValue(anAuthor[[2]])
    initials <- xmlValue(anAuthor[[3]])

    newAuthors.df[m,1] <- lname
    newAuthors.df[m,2] <- fname
    newAuthors.df[m,3] <- initials
  }
  
  return(newAuthors.df)
}

# Taken from Prof. Schedlbauer's "Parsing an XML Document and Saving to SQL Database"
rowExists <- function (aRow, aDF)
{
  # check if that address is already in the data frame
  n <- nrow(aDF)
  c <- ncol(aDF)
  if (n == 0)
  {
    # data frame is empty, so can't exist
    return(0)
  }
  for (a in 1:n)
  {
    # check if all columns match for a row; ignore the aID column
    if (all(aDF[a,] == aRow[1,]))
    {
      # found a match; return it's ID
      return(a)
    }
  }
  # none matched
  return(0)
}
```

##### Main processing loop
```{r}
# iterate over the first-level child elements off the root:
# the <PubmedArticle> elements

for (i in 1:numArticle)
{
  # get next article node
  currArticle <- r[[i]]
  medline <- currArticle[[1]]
  
  # Grab the PMID as article_id
  article_id <- as.numeric(xmlValue(medline[[1]]))
  
  # article node can be 3rd or 4th child depending on if there's a revised date
  articleNode <- medline[[4]]
  if (xmlName(articleNode) != "Article") {
    articleNode <- medline[[5]]
  }
  
  # Pull values out when possible, and prepare nodes for helper functions
  journalNode <- articleNode[[1]]
  title <- xmlValue(articleNode[[2]])
  # pagination is stored in child of pagination node
  pagNode <- articleNode[[3]]
  pagination <- xmlValue(pagNode[[1]])
  eLocationID <- xmlValue(articleNode[[4]])
  authorList <- articleNode[[6]]
  language <- xmlValue(articleNode[[7]])
  
  # Process the journal entry
  journal <- parseJournal(journalNode)
  # check if the journal already exists. If so get it's id
  pk.Journal <- rowExists(journal, Journal.df[,2:ncol(Journal.df)])
  
  if (pk.Journal == 0)
  {
    # does not exist, so add
    pk.Journal <- nrow(Journal.df) + 1
    Journal.df[pk.Journal,2:ncol(Journal.df)] <- journal[1,]
    Journal.df[pk.Journal,1] <- pk.Journal
  }
  
  # set FK in Article to the Journal ID
  Article.df$journal_id[i] <- pk.Journal
  
  # parse author list next
  authors <- parseAuthors(authorList)
  
  # check each entry in authors if it's in the database already
  # We also link the authorship table to article and author in here
  for (j in 1:nrow(authors)) {
    author.tempdf <- data.frame(authors$lname[j], authors$fname[j], authors$initials[j])
    pk.Author <- rowExists(author.tempdf, Author.df[,2:4])
    if (pk.Author == 0) {
      # does not exist, so add to author table
      pk.Author <- nrow(Author.df) + 1
      Author.df[pk.Author,2:ncol(Journal.df)] <- authors[j,]
      Author.df[pk.Author,1] <- pk.Author
      
      # also have to link to authorship table
      authorship <- c(article_id, pk.Author)
      newrow <- nrow(Authorship.df) + 1
      Authorship.df[newrow,] <- authorship
    } else # otherwise we still need to make the authorship link
      {
      authorship <- c(article_id, pk.Author)
      newrow <- nrow(Authorship.df) + 1
      Authorship.df[newrow,] <- authorship
    }
  }
}
```

```{r}
Author.df
Article.df
Authorship.df
Journal.df
```






```{r}
dbDisconnect(part1db)
```

