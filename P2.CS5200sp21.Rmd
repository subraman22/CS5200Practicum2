---
title: "Practicum 2"
output: html_notebook
---

##### Import statements
```{r}
library(RSQLite)
library(XML)
library(DBI)
library(knitr)
```
### Part 1
##### ERD for the schema
![Transactional Database ERD](Part1ERD.png)

##### creating databse connection
```{r}
path <- "/Users/rohan/Documents/Masters/5200Databases/Practicum2/"
fn <- "pubmed_sample.xml"
fpn = paste0(path, fn)
dbfn <- "part1.db"
dbfpn = paste0(path, dbfn)

part1db <- dbConnect(RSQLite::SQLite(), dbfpn)
```

```{sql connection=part1db}
DROP TABLE IF EXISTS Article;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Authorship;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Author;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS Journal;
```

##### Create table schema
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Journal (
  jornal_id INT PRIMARY KEY,
  ISSN TEXT NOT NULL,
  volume INT NOT NULL,
  issue INT NOT NULL,
  pubYear TEXT NOT NULL,
  pubMonth TEXT,
  title TEXT NOT NULL,
  ISOabbreviation TEXT NOT NULL
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Author (
  author_id INT PRIMARY KEY,
  lname TEXT NOT NULL,
  fname TEXT NOT NULL,
  initials TEXT NOT NULL
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Article (
  article_id INT PRIMARY KEY,
  journal_id INT NOT NULL,
  title TEXT NOT NULL,
  pagination TEXT,
  eLocationID TEXT,
  language TEXT,
  FOREIGN KEY (journal_id) REFERENCES Journal(journal_id)
)
```
```{sql connection=part1db}
CREATE TABLE IF NOT EXISTS Authorship (
  author_id INT NOT NULL,
  article_id INT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES Author(author_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id)
)
```
```{sql connection=part1db}
SELECT 
    name
FROM 
    sqlite_master 
WHERE 
    type ='table' AND 
    name NOT LIKE 'sqlite_%';
```

##### Part 1 #3 dataframes to load into the database
```{r}
# Reading the XML file and parse into DOM
xmlDOM <- xmlParse(file = fpn)
# get the root node of the DOM tree
r <- xmlRoot(xmlDOM)
# get number of children of root (number of articles)
numArticle <- xmlSize(r)
# create various data frames to hold data; initial values are just
# to define data type and length and will be replaced; pre-allocation
# is better for performance than dynamic allocation of memory
Article.df <- data.frame (article_id = vector (mode = "integer", 
                                     length = numArticle),
                     journal_id = vector (mode = "integer", 
                                         length = numArticle),
                     title = vector (mode = "character", 
                                       length = numArticle),
                     pagination = vector (mode = "character", 
                                        length = numArticle),
                     eLocationID = vector (mode = "character", 
                                        length = numArticle),
                     language = vector (mode = "character", 
                                        length = numArticle),
                     stringsAsFactors = F)
Journal.df <- data.frame (jid = integer(),
                          issn = character(),
                          volume = integer(),
                          issue = integer(),
                          pubYear = integer(),
                          pubMonth = integer(),
                          title = character(),
                          ISOabbrev = character(),
                          stringsAsFactors = F)
Author.df <- data.frame (aid = integer(),
                       lname = character(),
                       fname = character(),
                       initials = character(),
                       stringsAsFactors = F)
Authorship.df <- data.frame (articleID = integer(),
                       authorID = integer(),
                       stringsAsFactors = F)
authorList.df <- data.frame(aid = integer(),
                       author1 = character(),
                       author2 = character(),
                       author3 = character(),
                       author4 = character(),
                       author5 = character(),
                       author6 = character(),
                       author7 = character(),
                       author8 = character(),
                       author9 = character(),
                       author10 = character(),
                      author11 = character(),
                      author12 = character(),
                       stringsAsFactors = F)
```

##### Helper functions
```{r}
parseJournal <- function (aJournalNode)
{
  # parse the address into its components
  issn <- xmlValue(aJournalNode[[1]])
  issueNode <- aJournalNode[[2]]
  title <- xmlValue(aJournalNode[[3]])
  ISOabbrev <- xmlValue(aJournalNode[[4]])
  
  volume <- as.numeric(xmlValue(issueNode[[1]]))
  issue <- as.numeric(xmlValue(issueNode[[2]]))
  dateNode <- issueNode[[3]]
  
  # Check if the PubDate is a MedlineDate type
  if (xmlName(dateNode[[1]]) == "MedlineDate") {
    pubDate <- xmlValue(dateNode[[1]])
    pubYear <- as.numeric(substr(pubDate, 1, 4))
    pubMonth <- substr(pubDate, 6, 8)
    pubMonth <- match(pubMonth,month.abb)
  } else { # Otherwise it's in Year and Month format
    pubYear <- xmlValue(dateNode[[1]])
    pubMonth <- xpathSApply(dateNode, "./Month", xmlValue)
    if (length(pubMonth) == 0) {
      pubMonth <- NA
    } else {
      pubMonth <- match(pubMonth,month.abb)
    }
  }
  
  newJournal.df <- data.frame(issn, volume, issue, pubYear, 
                              pubMonth, title, ISOabbrev, 
                           stringsAsFactors = F)
  
  return(newJournal.df)
}
parseAuthors <- function(AuthorListNode)
{
  newAuthors.df <- data.frame (lname = character(),
                                fname = character(),
                                initials = character(),
                                stringsAsFactors = F)
  n <- xmlSize(AuthorListNode)
  
  # extract each of the <Author> nodes under <AuthorList>
  for (m in 1:n)
  {
    anAuthor <- AuthorListNode[[m]]
    lname <- xmlValue(anAuthor[[1]])
    fname <- xmlValue(anAuthor[[2]])
    initials <- xmlValue(anAuthor[[3]])
    newAuthors.df[m,1] <- lname
    newAuthors.df[m,2] <- fname
    newAuthors.df[m,3] <- initials
  }
  
  return(newAuthors.df)
}
# Taken from Prof. Schedlbauer's "Parsing an XML Document and Saving to SQL Database"
rowExists <- function (aRow, aDF)
{
  # check if that address is already in the data frame
  n <- nrow(aDF)
  c <- ncol(aDF)
  if (n == 0)
  {
    # data frame is empty, so can't exist
    return(0)
  }
  for (a in 1:n)
  {
    # check if all columns match for a row; ignore the aID column
    if (all(aDF[a,] == aRow[1,]))
    {
      # found a match; return it's ID
      return(a)
    }
  }
  # none matched
  return(0)
}
```

##### Main processing loop
```{r}
# iterate over the first-level child elements off the root:
# the <PubmedArticle> elements
for (i in 1:numArticle)
{
  # get next article node
  currArticle <- r[[i]]
  medline <- currArticle[[1]]
  
  # Grab the PMID as article_id
  article_id <- as.numeric(xmlValue(medline[[1]]))
  
  # article node can be 4th or 5th child depending on if there's a revised date
  articleNode <- medline[[4]]
  if (xmlName(articleNode) != "Article") {
    articleNode <- medline[[5]]
  }
  
  # Pull values out when possible, and prepare nodes for helper functions
  journalNode <- articleNode[[1]]
  title <- xmlValue(articleNode[[2]])
  # pagination is stored in child of pagination node
  pagNode <- articleNode[[3]]
  pagination <- xmlValue(pagNode[[1]])
  eLocationID <- xmlValue(articleNode[[4]])
  authorList <- articleNode[[6]]
  language <- xmlValue(articleNode[[7]])
  if (xmlName(authorList) != "AuthorList") {
    authorList <- articleNode[[7]]
    language <- xmlValue(articleNode[[8]])
  }
  
  
  # Process the journal entry
  journal <- parseJournal(journalNode)
  # check if the journal already exists. If so get it's id
  pk.Journal <- rowExists(journal, Journal.df[,2:ncol(Journal.df)])
  
  if (pk.Journal == 0)
  {
    # does not exist, so add
    pk.Journal <- nrow(Journal.df) + 1
    Journal.df[pk.Journal,2:ncol(Journal.df)] <- journal[1,]
    Journal.df[pk.Journal,1] <- pk.Journal
  }
  
  # set FK in Article to the Journal ID
  Article.df$journal_id[i] <- pk.Journal
  
  # parse author list next
  authors <- parseAuthors(authorList)
  
  # check each entry in authors if it's in the database already
  # We also link the authorship table to article and author in here
  authorList.tempdf <- data.frame(matrix(NA, nrow = 1, ncol = 12))
  
  for (j in 1:nrow(authors)) {
    authorList.tempdf[1, j] <- paste0(authors$lname[j], ", ", authors$fname[j])
    pk.Author <- rowExists(authors[j,], Author.df[,2:4])
    if (pk.Author == 0) {
      # does not exist, so add to author table
      pk.Author <- nrow(Author.df) + 1
      Author.df[pk.Author,2:ncol(Author.df)] <- authors[j,]
      Author.df[pk.Author,1] <- pk.Author
      
      # also have to link to authorship table
      authorship <- c(article_id, pk.Author)
      newrow <- nrow(Authorship.df) + 1
      Authorship.df[newrow,] <- authorship
    } else # otherwise we still need to make the authorship link
      {
      authorship <- c(article_id, pk.Author)
      newrow <- nrow(Authorship.df) + 1
      Authorship.df[newrow,] <- authorship
    }
  }
  authorList.df[i, 1] <- article_id
  authorList.df[i,2:13] <- authorList.tempdf
  
  # Put the rest of the stuff into Article data frame
  Article.df[i,1] <- article_id
  Article.df[i,3] <- title
  Article.df[i,4] <- pagination
  Article.df[i,5] <- eLocationID
  Article.df[i,6] <- language
}
```

```{r}
Author.df
Article.df
Authorship.df
Journal.df
authorList.df
```
```{r}
dbWriteTable(part1db, "Journal", Journal.df, overwrite = T)
dbWriteTable(part1db, "Author", Author.df, overwrite = T)
dbWriteTable(part1db, "Article", Article.df, overwrite = T)
dbWriteTable(part1db, "Authorship", Authorship.df, overwrite = T)
dbWriteTable(part1db, "authorList", authorList.df, overwrite = T)
```

```{sql connection=part1db}
SELECT *
FROM Author 
WHERE fname LIKE "Ya%Lin";
```

Specifically with the author Ya Lin Chiu, there's 3 entries because there's 3
different spellings that the rowExists function didn't pick up
### Part 2
![Analytical Database ERD](Part2ERD.png)


![Analytical Database ERD]()

```{sql connection=part1db}
-- drop the tables if they already exist
DROP TABLE IF EXISTS ArticleFact;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS AuthorListDim;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS JournalDim;
```
```{sql connection=part1db}
DROP TABLE IF EXISTS QuarterDim;
```


do we need pubmonth and pubyear here? it's in quarter dim now

```{sql connection=part1db}
CREATE TABLE JournalDim
   AS SELECT jid AS journalDim_id, ISSN, volume, issue, --pubYear, pubMonth,
   title, ISOabbrev FROM Journal;
```
```{sql connection=part1db}
CREATE TABLE AuthorListDim
   AS SELECT * FROM authorList;
```
```{sql connection=part1db} 
CREATE TABLE QuarterDim (
  datetimedim_key INT PRIMARY KEY,
  year INT,
  quarter INT,
  month INT
);
```
```{sql connection=part1db}
INSERT INTO QuarterDim (year, quarter, month)
SELECT DISTINCT pubYear,
CASE
  WHEN pubMonth IN (1, 2, 3) THEN 1
  WHEN pubMonth IN (4, 5, 6) THEN 2
  WHEN pubMonth IN (7, 8, 9) THEN 3
  WHEN pubMonth IN (10, 11, 12) THEN 4
  ELSE 0
END, pubMonth
FROM Journal;

```
```{sql connection=part1db}
UPDATE QuarterDim
SET datetimedim_key = rowid 
```


```{sql connection=part1db}
SELECT * FROM QuarterDim

```
```{sql connection=part1db}
CREATE TABLE ArticleFact (
journal_id INT,
authorList_id INT,
quarter_id INT,
PRIMARY KEY (journal_id, authorList_id, quarter_id)
);
```

```{sql connection=part1db}
INSERT INTO ArticleFact
SELECT a.journal_id, a.article_id, q.datetimedim_key
FROM Article a
JOIN Journal j ON a.journal_id = j.jid
JOIN QuarterDim q ON j.pubYear = q.year AND j.pubMonth = q.month

```

```{sql connection=part1db}
SELECT * FROM ArticleFact af
JOIN AuthorListDim al ON al.aid = af.authorList_id

```

```{sql connection=part1db}
SELECT Distinct ISSN FROM journal
```

```{r}
dbDisconnect(part1db)
```
